### 定义

分区是指通过将海量的数据集分配到多台机器，来提升存储容量和吞吐量的一种方案。

单台机器无法存储海量的数据集，CPU、IO资源也无法满足应用的高吞吐量需求，即垂直扩展并不能无限制的增加单台机器的配置。通过将数据集进行拆分，使不同的数据子集分布到不同的磁盘，查询负载分布到不同的处理器即是分区。

**分区会带来哪些好处呢？**

* 可伸缩性：通过增加机器就可以很方便的扩展。
* 可用性：分区之间相互独立，分散了风险。
* 性能：每个分区就是一个小型的独立数据库。

**分区会引入哪些问题？**

* 复杂度：跨分区的数据查询，以及跨分区的事务操作，以及存储系统本身的复杂度
* 数据倾斜导致的热点问题



分区与复制通常结合使用，即每个分区在多个节点都存有副本。一个节点可以存储多个分区。例如：

![fig6-1](/Users/zego/Pictures/fig6-1.png)



### 分区策略

分区目标是将数据和查询负载均匀的分布在各个节点上。如果每个节点公平分享数据和负载，那么理论上10个节点应该能够处理10倍的数据量和10倍的单个节点的读写吞吐量（忽略复制）。

如果分区不均匀，某个分区有更多的数据或者查询，称之为倾斜。倾斜会导致分区效率的严重下降，极端情况下，所有的负载可能会集中在一个分区。这种负载严重不成比例的分区即为系统热点。



**范围分区**

通过按照数据的key，或者用户指定的一个或多个字段计算结果所在的分区范围来确定数据所在分区。

范围分区通过手动指定分区的范围，也能够使数据分布的较为均匀。但是对于类似于按照日期来进行分区，当天的数据写入都会落在一个分区这样的场景，很容易造成热点。为了避免这种问题，需要使用除了时间以外的其他字段作为键的第一个部分。



**散列分区**

通过按照数据的key、或者用户指定的一个或者多个字段计算哈希，然后将计算后的哈希与计算节点进行映射，从而将不同哈希值的数据分布到不同节点上。

散列分区对范围查询不友好，需要向所有的分区发送范围查询请求再做整合。

好的散列算法可以使数据均匀分布，但仍不能完全避免热点问题。极端情况下，所有的读写操作都是针对同一个键的。这种情况下，一般需要业务层给散列的key添加前、后缀，从而将数据拆分到不同的分区，这样做的代价是读取变得更加复杂，需要跨分区读取进行合并。



**其他分区方式**

* 基于目录分区：维护一个查找表来记录记录所在的分区
* 动态分区：对数据分布不均匀的数据较试用，通过给分区设置大小的区间阈值，当分区过大时进行分裂，过小时合并，类似于B树。



### 请求路由

一般来说有以下几种方案：

* 允许客户联系任何节点（例如，通过**循环策略的负载均衡（Round-Robin Load Balancer）**）。如果该节点恰巧拥有请求的分区，则它可以直接处理该请求；否则，它将请求转发到适当的节点，接收回复并传递给客户端。
* 首先将所有来自客户端的请求发送到路由层，它决定了应该处理请求的节点，并相应地转发。此路由层本身不处理任何请求；它仅负责分区的负载均衡。

* 要求客户端知道分区和节点的分配。在这种情况下，客户端可以直接连接到适当的节点，而不需要任何中介。

![fig6-7](/Users/zego/Pictures/fig6-7.png)



### 什么情况下需要分区？

由于分区架构所带来的复杂度，一般情况下，只有在业务拥有非常大量的数据集时采用。在对数据进行分区之前，最好是优先采用其他方式来优化存储系统。

* 根据业务或者服务来分库，避免不同的服务依赖同一个节点
* 使用缓存
* 创建只读从库
* 提升机器配置

只有当数据增长到一定量级时，以上的这些方法不足以有效改进性能时，分区才是最佳选择。例如：

* 应用数据不断增长，超出了单点数据库的存储能力。

* 数据库的读写超出了单点数据库或只读从库（读写分离架构下，译者注）的处理能力，从而导致了响应慢或超时。

* 应用所需的网络带宽超出了单点数据库或只读从库的可用带宽，从而导致了响应慢或超时。



【参考资料】

[Designing Data-Intensive Applications](https://github.com/Vonng/ddia/blob/master/ch6.md)

[理解数据库分片](https://github.com/xitu/gold-miner/blob/master/TODO1/understanding-database-sharding.md)

[MongoDB分片](https://docs.mongoing.com/fen-pian#ha-xi-fen-pian)